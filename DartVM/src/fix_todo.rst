
Mintのサイズ
===============================================================================
Mintは、64bitでも32bitでも64bit幅
x64では、Mintはほぼ存在しない。
ia32の場合は、気にしたコードを書く必要がある。

nullを含むequality演算に関して
===============================================================================
多くのEquality演算は、nullが入ってくる可能性がある。
!= nullとした際に、Equality演算の方は、buffとnull型になる。
PolymorphicCallに確定する???

むかしはPolymorphiCallだったが、今のEquality系の中間表現は、
nullが入ってもpolymorphicにならないように、nullのケースをEmitする仕組みになっている。

Representations
===============================================================================
double型の変数をループで回した場合も、
repreでdoubleからunboxingされる。


Polyrmophicの除外
===============================================================================
toString()はPolyになりやすい。これは例外的。
組み込み型は、runtime側で実装されており、polyになる可能性がない。
例をあげると、List<int>など。Listの実装はruntimeにある。

int./ のpoly化
===============================================================================
issueに報告済み。
intの切り捨て除算は、~/ trunc divが該当するので、注意すること。

/は、double型の値が返る。
checked-modeだと、doubleになるため、errorかwarningになっている。

methodの糖衣構文
===============================================================================

IC[ smi, double]は、smi型になる。

(int) a + (double) bは、
a.+(double b)の糖衣構文であるため、aの型に依存したメソッドが呼ばれる。
dartの構文上、2項演算や、第1引数で決まる。


Randomクラスが遅い理由
===============================================================================
smi << がbigintになってめちゃくちゃ遅い。
issueに報告済み。
ボトルネックは、_nextInt32()
int _nextInt32() {
  // ここが全体の90%
  _state = ((_A * (_state & _MASK_32)) + (_state >> 32)) & _MASK_64;
  return _state & _MASK_32;
}


15000くらいで、 _stateが_high, _lowに分割して保持するように修正はいった。

ia32だと遅いけど、x64だとMintが畳み込まれてそこそこ速くなる見込み。

intの<<は、どうやってbigint化するのを抑止するのか、今後の改善頼み。
javaのような<<の動作を期待すると遅くなる。移植時の注意点。



optimization_counter_threshold
===============================================================================
初期値は2000であるため、オプション操作するとhotcodeの判定回数が変わるはず。
だけど2000以外を指定しても、2000のまま動作する。

dartvmのコンパイル時にcounter=2000を参照するアセンブラを生成しているらしく、
実行時には意味のない値になっているかも。

最適化コンパイルされた際に、1度も実行されなかった関数が、ICのまま
===============================================================================
修正入った。
最適化コンパイル時に1度も実行されなかったICは、ICのままコンパイルされる。
そのため、特殊化されない。

今は、未実行のICは、deoptimize実行命令に置き換えられている。
そのため、最適化コンパイルされた関数を実行した際に、
1度も実行されていないICを含むパスに入った場合、Deoptimizeされる。

Float64ArrayCid
===============================================================================
LoadIndexedInstr::representation()で、
UnboxDouble型であることが付与されている。素晴らしい。


Optional Parameterの扱い
===============================================================================
冒頭でif elseに展開している。

List<>のnewの場合、length==0を冒頭で計算して、
Glorableか、Arrayのnewを切り分けている。


===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
